<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Blast</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(to bottom, #6db3f2, #1e69de);
            color: #fff;
            font-family: Arial, sans-serif;
            height: 100vh;
            overflow: hidden;
        }

        h1 {
            font-size: 36px;
            margin: 20px 0;
        }

        .game-container {
            position: relative;
            width: 400px;
            height: 400px;
            background-color: #2c3e50;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 1px;
        }

        .grid-cell {
            background-color: #34495e;
            width: 100%;
            height: 100%;
        }

        .grid-cell.filled {
            background-color: #e74c3c;
        }

        .blocks-container {
            display: flex;
            justify-content: center;
            margin-top: 20px;
        }

        .block {
            display: inline-block;
            position: absolute;
            z-index: 100;
        }

        .block-piece {
            background-color: #3498db;
            width: 50px;
            height: 50px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>
<body>
    <h1>Block Blast</h1>
    <div class="game-container"></div>
    <div class="blocks-container"></div>

    <script>
        const GRID_SIZE = 8;
        const CELL_SIZE = 50;

        const gameContainer = document.querySelector('.game-container');
        const blocksContainer = document.querySelector('.blocks-container');
        let gameGrid = JSON.parse(localStorage.getItem('blockBlastGrid')) || Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(0));

        function renderGrid() {
            gameContainer.innerHTML = '';
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    if (gameGrid[y][x] === 1) {
                        cell.classList.add('filled');
                    }
                    gameContainer.appendChild(cell);
                }
            }
        }

        function generateShapes() {
            blocksContainer.innerHTML = '';
            for (let i = 0; i < 3; i++) {
                createBlock(generateRandomShape());
            }
        }

        function createBlock(shape) {
            const block = document.createElement('div');
            block.className = 'block';
            block.dataset.shape = JSON.stringify(shape);

            shape.forEach((row, y) => {
                row.forEach((cell, x) => {
                    if (cell === 1) {
                        const blockPiece = document.createElement('div');
                        blockPiece.className = 'block-piece';
                        blockPiece.style.left = `${x * CELL_SIZE}px`;
                        blockPiece.style.top = `${y * CELL_SIZE}px`;
                        block.appendChild(blockPiece);
                    }
                });
            });

            block.addEventListener('mousedown', onDragStart);
            block.addEventListener('touchstart', onDragStart, { passive: false });
            blocksContainer.appendChild(block);
        }

        function generateRandomShape() {
            const shapes = [
                [[1, 1, 1]],
                [[1], [1], [1]],
                [[1, 1], [1, 1]],
                [[1, 1, 0], [0, 1, 1]],
                [[0, 1, 1], [1, 1, 0]]
            ];
            return shapes[Math.floor(Math.random() * shapes.length)];
        }

        function snapToGrid(block, x, y) {
            const gridX = Math.floor(x / CELL_SIZE);
            const gridY = Math.floor(y / CELL_SIZE);
            const blockShape = JSON.parse(block.dataset.shape);

            if (canPlaceShape(gridX, gridY, blockShape)) {
                placeShape(gridX, gridY, blockShape);
                block.remove();
                if (blocksContainer.children.length === 0) {
                    generateShapes();
                }
            } else {
                resetBlockPosition(block);
            }
        }

        function canPlaceShape(gridX, gridY, shape) {
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col] === 1) {
                        const cellX = gridX + col;
                        const cellY = gridY + row;
                        if (
                            cellX < 0 || cellX >= GRID_SIZE ||
                            cellY < 0 || cellY >= GRID_SIZE ||
                            gameGrid[cellY][cellX] !== 0
                        ) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        function placeShape(gridX, gridY, shape) {
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col] === 1) {
                        gameGrid[gridY + row][gridX + col] = 1;
                    }
                }
            }
            saveGameState();
            renderGrid();
        }

        function resetBlockPosition(block) {
            block.style.left = block.dataset.startX;
            block.style.top = block.dataset.startY;
        }

        function onDragStart(event) {
            const block = event.target.closest('.block');
            const rect = block.getBoundingClientRect();
            let offsetX, offsetY;

            if (event.type === 'mousedown') {
                offsetX = event.clientX - rect.left;
                offsetY = event.clientY - rect.top;
            } else if (event.type === 'touchstart') {
                offsetX = event.touches[0].clientX - rect.left;
                offsetY = event.touches[0].clientY - rect.top;
            }

            block.dataset.startX = block.style.left || '0px';
            block.dataset.startY = block.style.top || '0px';

            const moveBlock = (e) => {
                let x, y;
                if (e.type === 'mousemove') {
                    x = e.clientX - offsetX;
                    y = e.clientY - offsetY;
                } else if (e.type === 'touchmove') {
                    x = e.touches[0].clientX - offsetX;
                    y = e.touches[0].clientY - offsetY;
                }

                block.style.position = 'absolute';
                block.style.zIndex = 1000;
                block.style.left = `${x}px`;
                block.style.top = `${y}px`;
            };

            const stopDragging = (e) => {
                let x, y;
                if (e.type === 'mouseup') {
                    x = e.clientX;
                    y = e.clientY;
                } else if (e.type === 'touchend') {
                    x = e.changedTouches[0].clientX;
                    y = e.changedTouches[0].clientY;
                }

                document.removeEventListener('mousemove', moveBlock);
                document.removeEventListener('mouseup', stopDragging);
                document.removeEventListener('touchmove', moveBlock);
                document.removeEventListener('touchend', stopDragging);

                snapToGrid(block, x, y);
            };

            document.addEventListener('mousemove', moveBlock);
            document.addEventListener('mouseup', stopDragging);
            document.addEventListener('touchmove', moveBlock, { passive: false });
            document.addEventListener('touchend', stopDragging);
        }

        function saveGameState() {
            localStorage.setItem('blockBlastGrid', JSON.stringify(gameGrid));
        }

        function loadGameState() {
            const savedGrid = localStorage.getItem('blockBlastGrid');
            if (savedGrid) {
                gameGrid = JSON.parse(savedGrid);
            }
            renderGrid();
        }

        loadGameState();
        renderGrid();
        generateShapes();
    </script>
</body>
</html>
